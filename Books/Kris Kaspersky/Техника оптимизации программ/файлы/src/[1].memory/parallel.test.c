/* ---------------------------------------------------------------------------
 * @
 *
 *		УТИЛИТА ДЛЯ ДЕМОНСТАЦИИ ЭФФЕКТИВНОСТИ ПАРАЛЛЕЛЬНОГО ЧТЕНИЯ ПАМЯТИ
 *		=================================================================
 *
 * Build 0x003	12.06.2002
 * Build 0x002	20.05.2002
--------------------------------------------------------------------------- */

// КОНФИГУРАЦИЯ
#define _BLOCK_SIZE			(16*M)					// размер обрабатываемого блока
#define _STEP_SIZE			(L1_CACHE_SIZE)			// размер обрабатываемого под-блока


#include <DoCPU.h>
main()
{
	int a, b;
	int x = 0;
	int *p;
	int BLOCK_SIZE = _BLOCK_SIZE;
	int STEP_SIZE  = _STEP_SIZE;
	
	// Выделение памяти
	p = malloc(BLOCK_SIZE);

	// TITLE
	PRINT("=== демонстрация эффективности параллельного чтения ===\n");
	PRINT_TITLE;
	PRINT("------------------ Тестирование ------------------\n");

	/* -----------------------------------------------------------------------
	 *
	 *	измерение пропускной способности при последовательном чтении данных
	 *
	----------------------------------------------------------------------- */
	CLEAR_L2_CACHE();VVV;
	A_BEGIN(1)
		for (a=0; a<BLOCK_SIZE; a += 8 * sizeof(int))
		{
			// загружаем первую ячейку
			// поскольку ее пока нет в кэше,
			// процессор отправляет чипсету
			// запрос на ее чтение
			x += *(int *)((char *)p + a + 0 * sizeof(int));

			// загружаем следующую ячейку
			// поскольку зависимости по данным нет,
			// процессор может выполнять эту команду,
			// не дожидаясь результатов предыдущей
			// однако, поскольку процессор видит,
			// что эта ячейка возвращается с предыдущим
			// запросом, он не генерирует нового запроса,
			// а ждет завершения текущего
			x += *(int *)((char *)p + a + 1 * sizeof(int));

			// аналогично - процессор ждет завершения
			// первого запроса...
			x += *(int *)((char *)p + a + 2 * sizeof(int));
			x += *(int *)((char *)p + a + 3 * sizeof(int));
			x += *(int *)((char *)p + a + 4 * sizeof(int));
			x += *(int *)((char *)p + a + 5 * sizeof(int));
			x += *(int *)((char *)p + a + 6 * sizeof(int));
			x += *(int *)((char *)p + a + 7 * sizeof(int));
		}
	A_END(1)

	printf("%s:\t %4.2f (Mbytes/s)\n",	/* вывод результатов на экран */
		_TEXT("Последовательное чтение"),((BLOCK_SIZE)/cpu2time(Ax_GET(1))));


	/* -----------------------------------------------------------------------
	 *
	 *	Измерение пропускной способности при параллельном чтении данных
	 *
	----------------------------------------------------------------------- */
	CLEAR_L2_CACHE();VVV;
	A_BEGIN(2)
		for (b = 0; b < BLOCK_SIZE; b += STEP_SIZE)
		{						//       ^^^^^^	размер обрабатываемого блока
								//				не должен превосходить размер
								//				кэша первого уровня

			// первый проход цикла в котором осуществляется
			// параллельная загрузка данных
			for (a=b; a<(b+STEP_SIZE); a+= 128)
			{
				// загружаем первую ячейку
				// поскольку ее пока нет в кэше,
				// процессор отправляет чипсету
				// запрос на ее чтение
				x += *(int *)((char *)p + a + 0);

				// загружаем следующую ячейку
				// поскольку зависимости по данным нет,
				// процессор может выполнять эту команду,
				// не дожидаясь результатов предыдущей
				// но, поскольку процессор видит, что
				// данная ячейка не возвратиться с
				// только что запрошенным блоком,
				// он направляет еще чипсету еще один запрос
				// не дожидаясь завершения предыдущего
				x += *(int *)((char *)p + a + 32);

				// аналогично, - теперь на шине уже три запроса!
				x += *(int *)((char *)p + a + 64);

				// на шину отправляется четвертый запрос
				// причем, первый запрос возможно еще и
				// не завершен
				x += *(int *)((char *)p + a + 96);
			}

			for (a=b; a<(b+STEP_SIZE); a += 32)
			{
				// следующую ячейку читать не надо
				// т.к. она уже прочитана в первом цикле
				// x += *(int *)((char *)p + a + 0);

				// а эти ячейки уже будут в кэше!
				// и они смогут загрузиться быстро-быстро!
				x += *(int *)((char *)p + a + 4);
				x += *(int *)((char *)p + a + 8);
				x += *(int *)((char *)p + a + 12);
				x += *(int *)((char *)p + a + 16);
				x += *(int *)((char *)p + a + 20);
				x += *(int *)((char *)p + a + 24);
				x += *(int *)((char *)p + a + 28);
			}
		}
	A_END(2)

	printf("%s:\t %4.2f (Mbytes/s)\n",	/* вывод результатов на экран */
		_TEXT("Чтение с шагом 32 байта"),(BLOCK_SIZE)/cpu2time(Ax_GET(2)));
	PRINT(_TEXT("--------------------------------------------------\n"));

return x;

}

_P_S()
{
/*
	Люди  Запада  делятся  на  две  категории:  меньшинство  составляют кошки,
	гуляющие  сами  по  себе - сильные и ловкие хищники-одиночки, способные до
	поры  прятать  свои  когти в мягких подушечках; большинство же - обезьяны,
	животные  сугубо  общественные, придерживающиеся строгой иерархии, шумные,
	суетливые  и всеядные, охотно перенимающие чужие навыки и не без основания
	служащие  объектом  насмешек. Азиаты - змеи, скрытные, коварные, привыкшие
	пресмыкаться, но от этого лишь более опасные, не самые умные, но способные
	восхищать  своим смертоносным изяществом, незаметные до времени, а потом -
	убивающие  наверняка одним молниеносным броском. А русские - бродячие псы,
	вечно  тоскующие  по  хозяину,  живущие  стаями, с навыком травли в генах,
	хорошо  понимающие  язык  палки,  большие любители повыть на луну и всегда
	готовые загрызть всякого, кто не похож на них".
															(c) Юрий Нестеренко
*/
}