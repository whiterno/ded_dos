/* ---------------------------------------------------------------------------
 * @
 *							УТИЛИТА ДЕМОНСТРИРУЮЩАЯ
 *
 *						Н Е Э Ф Ф Е К Т И В Н О С Т Ь
 *
 *					ВЫРАВНИВАНИЯ ПОТОКВЫХ ДАННЫХ ТИПА int
 *
 * Build 0x001 05.07.2002
--------------------------------------------------------------------------- */
// конфигурация
#define BLOCK_SIZE	(8*M)

// определение числа итераций
#define N			(BLOCK_SIZE/sizeof(int))


#include <DoCPU.h>

// -[Посчет суммы массива]----------------------------------------------------
//
//	ARG:
//		array	- указатель на массив
//		n		- кол-во элементов для сортировки
//
// README:
//		Функуия не выравнивает указатель на массив! Делайте это сами!
//----------------------------------------------------------------------------
int sum(int *array, int n)
{
	int a, x = 0;
	for(a = 0; a < n; a += 8)
	{
		x+=array[a + 0];
		x+=array[a + 1];
		x+=array[a + 2];
		x+=array[a + 3];
		x+=array[a + 4];
		x+=array[a + 5];
		x+=array[a + 6];
		x+=array[a + 7];
	}
	return x;
}

// -[Посчет суммы массива]----------------------------------------------------
//
//	ARG:
//		array	- указатель на массив
//		n		- кол-во элементов для сортировки
//
// README:
//		Функуия справляется с невыровненными массивами, и сама выравнивает их
//	(правда, было бы лучше, если бы она это не делала)
//----------------------------------------------------------------------------
int sum_align(int *array, int n)
{
	int a, x = 0;
	char supra_bytes[4];
//	supra_bytes=_malloc32(4);

		// внимание: это решения для _частного_ случая
		// когда array & 15== 1, т.е. попросту говоря,
		// указетль смещен на 1 байт вправо относительно
		// выровненного по границе 32 байт адреса
		// общее решение данной задачи без использования
		// циклов (цилы - снижают производительность)
		// невозможно!
		// единственный вариант - вручную создать свой
		// "обработчик" для каждой ситуации
		// всго их будет 32 - 32/4 = 24, что слишком
		// громоздко для книжного варианта
	if (((int)array & 15)!=1)
		ERROR("-ERR: Недопустимое выравнивание\n");
		
	for(a = 0; a < n; a += 8)
	{
		
		// копируем все двойные слова, которые
		// не пересекают границы пакетных циклов
		// обмена
		x+=array[a + 0];
		x+=array[a + 1];
		x+=array[a + 2];
		x+=array[a + 3];
		x+=array[a + 4];
		x+=array[a + 5];
		x+=array[a + 6];

		// двойное слово, пересекающие пакетный цикл
		// копируем во временный буфер по б а й т а м
		supra_bytes[0]=*((char *) array + (a+7)*sizeof(int) + 0);
		supra_bytes[1]=*((char *) array + (a+7)*sizeof(int) + 1);
		supra_bytes[2]=*((char *) array + (a+7)*sizeof(int) + 2);
		supra_bytes[3]=*((char *) array + (a+7)*sizeof(int) + 3);

		// извлекаем sura-байты и обрабатываем их как двойное слово
		x+=*(int *)supra_bytes;
	}

	return x;
}


main()
{
	int a;
	int *p;

	PRINT("= = = демонстрация н е э ф ф е к т и в н о с т и  выравнивания = = =\n");
	PRINT_TITLE;

	// выделяем память
	p = (int *) _malloc32(BLOCK_SIZE);

	/*------------------------------------------------------------------------
	 *
	 *					обрабатываем выровненный блок
	 *
	----------------------------------------------------------------------- */
	VVV;
	A_BEGIN(0)
		sum(p, N);
	A_END(0)

	/*------------------------------------------------------------------------
	 *
	 *					обрабатываем невыровненный блок
	 *
	----------------------------------------------------------------------- */
	// "уналиджим" указатель
	p = (int *)((int)p + 1);

	VVV;
	A_BEGIN(1)
		sum(p, N);
	A_END(1)

	/*------------------------------------------------------------------------
	 *
	 *				пытаемся выровнять блок из вызываемой функции
	 *
	----------------------------------------------------------------------- */
	VVV;
	A_BEGIN(2)
		sum_align(p, N);
	A_END(2)

	// вывод результатов на консоль
	Lx_OUT("unalign.....",Ax_GET(0),Ax_GET(1));
	Lx_OUT("try optimize",Ax_GET(0),Ax_GET(2));
	
	
}

_P_S()
{
/*
	Я  отказываю  в  сочувствии  ранам,  выставленным напоказ, которые трогают
	сердобольных    женщин,   отказываю   умирающим   и   мертвым.
											Антуан  де Сент-Экзюпери. Цитадель
*/
}



