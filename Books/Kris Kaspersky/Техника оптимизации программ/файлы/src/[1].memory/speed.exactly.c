/* ---------------------------------------------------------------------------
 * @
 *		УТИЛИТА ДЛЯ ИЗМЕРЕНИЯ РЕАЛЬНОЙ ПРОПУСКНОЙ СПОСОБНОСТИ ПАМЯТИ
 *					_С_ УЧЕТОМ ЛАТЕНТНОСТИ ЧИПСЕТА И CPU
 *		============================================================
 *
 * Build 0x001	03.04.2002
 * Build 0x002	16.05.2002
--------------------------------------------------------------------------- */

#include <DoCPU.h>

// преобразование float в int
#define _f2i(a) ((int) a)

// вычисление остатка от деления большего на меньший аргументы
#define remainder(a,b) (MAX(_f2i(a),_f2i(b)) % MIN(_f2i(a),_f2i(b)))

// ввод данных
#define _INPUT(s, var) printf(_TEXT(s));							\
	fgets(buff, MAX_STR_LEN - 1, stdin);							\
	if (buff[0]=='y' || buff[0]=='Y') var=1; else					\
	if (buff[0]=='n' || buff[0]=='N') var=0; else var=atof(buff);	\
/* end define _INPUT */

main()
{
	float Fcpu;					// тактовая частота CPU
	float FSB;					// тактовая частота системной шины
	float Ftransf;				// эффективная частота системной шины
	float Fm;					// тактовая частота памяти	

	float RAS_latency;			// RAS to CAS Delay
	float CAS_latency;			// CAS Delay
	float RAS_precharge;		// RAS Precharge Delay
	float LEN_page;				// длина DRAM-страниц
	float N;					// разрядность памяти

	float BRST_LEN;				// длина FSB-пакета
	float BRST_NUM;				// DRAM-пакетов в одном FSB-пакете

	float CPU_latency;			// латентность процессора
	float X_CACHE;				/* Отношение частоты процессора к
								^^ частоте работы L2-кэша */
	
	float C;					// пропускная способность

	int fInterleaving;			// есть чередования банков?

	int fSrl;					/* 0: паралельная передача данных от MCT к BIU
								^^ 1: передача данных через промежут буфер */

	int fMCT2BIUparallel;		/* 0: послед. передача  данных от буфера к BIU
								^^ 1: паралельная передача данных */

	int fImmediately;			/* 0: ячейка доступна по завершению танзакции
								^^ 1: ячейка доступна сразу */

	int Chipset_penalty = 0;	// пенальти на согласование частот FSB и памяти
	int CPU_penalty 	= 0;	// пенальти на согласование частот CPU и FSB

	char buff[MAX_STR_LEN];		// буфер под строки

	// TITLE
	PRINT("=== расчет пропускной способности памяти с учетом латентности чипсета ===\n");
	PRINT_TITLE; printf(_TEXT("\n-------------- введите --------------\n"));

	// ввод данных
	_INPUT("Частота процессора..... (MHz)?\t", Fcpu);
	_INPUT("Частота системной шины. (MHz)?\t", FSB);
	_INPUT("Частота передачи данных (MHz)?\t", Ftransf);
	_INPUT("Частота  работы  памяти (MHz)?\t", Fm);
	_INPUT("RAS to CAS latency..... (CLK)?\t", RAS_latency);
	_INPUT("CAS latency............ (CLK)?\t", CAS_latency);
	_INPUT("RAS precharge.......... (CLK)?\t", RAS_precharge);
	_INPUT("Длина строк DRAM памяти (Кил)?\t", LEN_page);
	_INPUT("Разрядность памяти..... (бит)?\t", N);
	_INPUT("Длина шинного пакета... (num)?\t", BRST_LEN);
	_INPUT("Длина DRAM-пакета...... (num)?\t", BRST_NUM);
	_INPUT("Латентность  процессора (CLK)?\t", CPU_latency);
	_INPUT("Частота CPU/L2 CACHE....(X/x)?\t", X_CACHE);
	_INPUT("Последовательный буфер..[y,n]?\t", fSrl);
	_INPUT("Чередование банков..... [y,n]?\t", fInterleaving);
	_INPUT("MCT2BIU parallel  mode  [y,n]?\t", fMCT2BIUparallel);
	_INPUT("Immediately-cache mode  [y,n]?\t", fImmediately);
	
	// проверка корректности ввода
	if (!BRST_NUM || !BRST_LEN) ERROR("Неверно указана длина пакета\x7")
		else BRST_NUM = BRST_LEN / BRST_NUM;

	if (!FSB || !Fm || !Fcpu)
			ERROR("-ERR: Частота не может быть равна нулю!\x7\n")

	if (!LEN_page)
			ERROR("-ERR: Длина страницы не может быть равна нулю!\x7\n")

	/* конец проверки корректности ввода */

	// вычисление пенальти
	if (remainder(FSB,Fm)	!=0)	Chipset_penalty = 1;
	if (remainder(FSB,Fcpu)	!=0)	CPU_penalty 	= 1;


	// перевод мегагерц в миллионы герц
	FSB*=Mega; Fm*=Mega; Fcpu*=Mega; Ftransf*=Mega; N/=Bit;


	//						ВЫЧИСЛЕНИЕ ПРОПУСКНОЙ СПОСОБНОСТИ
	// ------------------------------------------------------------------------
	C = (N /* разрядность памяти, байт */ * BRST_LEN /* длина пакета, итер */)/
		(
		  2/FSB						/* арбитраж 							*/
		+ 1/FSB						/* передача адреса ячейки				*/
		+ 1/FSB						/* передача идентификатора транзакции	*/

		+ 1/FSB						/* латентность BIU						*/

		+ 1/FSB						/* декодирование MCT адреса ячейки		*/

		+ 1/FSB						/* латентность MCT						*/

		+ Chipset_penalty/Fm		/* пенальти на согласов. частот Mem/FSB	*/

		+ BRST_NUM*CAS_latency/Fm	/* CAS Delay							*/

		+ (fSrl?BRST_LEN/Fm:1/Fm)	/* передача данных от DRAM к BUFF/BIU	*/

		+ Chipset_penalty/FSB		/* пенальти на согласование частот		*/

		+ (fMCT2BIUparallel?BRST_LEN/FSB:1/FSB)
									/* передача данных от BUFF к BIU		*/

		+ 1/FSB						/* латентность BIU						*/

		+ (fImmediately?1/FSB:BRST_LEN/Ftransf)
									/* передача данных от BIU к CPU			*/

		+ CPU_latency/Fcpu			/* латентность СPU						*/

		+ X_CACHE*BRST_LEN/Fcpu		/* передача данных от L2 к L1			*/

		+ CPU_penalty/Fcpu			/* пенальти на согласов. частот CPU/FSB	*/

		+ RAS_latency/((LEN_page*K/((N*BRST_LEN)))*Fm)
									/* задержка на открытие страницы памяти	*/

		+ (fInterleaving?0:RAS_precharge/Fm)
									/* задержка на перезаряд банка			*/
		);
		
	C /= M;							// Переводим миллионы байт в мегабайты

	// вывод результатов на экран
	printf("-------------------------------------\n%s =\t%4.2f\n",
		_TEXT("Пропускная способность (Мб/c)"),C);

	return 0;
}

_P_S_()
{
/*
	Между   тем  способности  человека  работать  с  большим  числом  связанных
	объектов,  как хорошо известно, весьма ограничены. В качестве ориентира при
	оценке  этих способностей указывают обычно на так называемое "число Ингве",
	равное  семи (плюс-минус 2). Другими словами, человек обычно не в состоянии
	уверенно   работать   с   объектом,   в  котором  более  семи  компонент  с
	произвольными   допустимыми   взаимными   связями.   До   тех   пор,   пока
	программирование   остается   в   основном  человеческой  деятельностью,  с
	указанным   ограничением   необходимо   считаться  
				КАУФМАН   В.Ш.   "Языки программирования: концепции и принципы"
*/
}
