; /*--------------------------------------------------------------------------
;  *
;  *		ј——≈ћЅЋ≈–Ќјя –≈јЋ»«ј÷»я ѕ–ќ÷≈ƒ”–џ ѕ”«џ–№ ќ¬ќ… —ќ–“»–ќ¬ »
;  *
; ------------------------------------------------------------------------- */
.386
.MODEL FLAT
.CODE

_asm_sort	proc
	MOV	EDX,[ESP+8]				; готовим n

	CMP	EDX,2					; есть ли хоть два числа дл€ сортировки?
	JB	@exit					; выход при неодостатке чисел

	PUSH	ESI					; \
	PUSH	EBP					;  |- сохран€ем регистры
	PUSH	EBX					; /
	
@while:							; do{
	MOV	ESI, [ESP+4+4*3]		;		готовим src
	MOV	EDX, [ESP+8+4*3]		;		готовим n

	XOR	EBP,EBP					;		сбрасываем флаг изменений

	NOP							;		это дл€ выравнивани€...
	NOP							;						...следующего цикла

@for:							;		do{
	MOV	EAX, [ESI]				;			берем очередное число
	MOV	EBX, [ESI+4]			;			берем число следующее за очередным

	CMP	EAX, EBX				;			если числа следуют в нужном нам
	JAE	@next_for				;			пор€дке, то все ок, в противном
								;			случае...
	MOV	EBP, EBX				;					...мы мен€ем их местами
	MOV	[ESI+4], EAX			;			добива€сь требуемого пор€дка
	MOV	[ESI],EBX				;			их следовани€
	
@next_for:
	ADD	ESI, 4					;			перемещаем указатель на след.
								;			сортируемое число

	DEC	EDX						;			уменьшаем кол-во обработанных
								;			(не отсортированных!) в этом
								;			проходе чисел на единицу
	JNZ	@for					;		} while (числа_еще_есть);

	OR	EBP,EBP					;		числа упор€дочены полностью?
	JNZ	@while					; } while(числа_не_будут_полностью_упор€дочены);

	POP	EBX						; \
	POP	EBP						;  |- восстанавливаем регистры
	POP	ESI						; /

@exit:
	ret							; возвращаемс€ из процедуры
_asm_sort endp

END

