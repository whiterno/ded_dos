/*----------------------------------------------------------------------------
 *
 *					ДЕМОНСТРАЦИЯ ПОСЛЕДОВАТЕЛЬНОСТИ АДРЕСОВ
 *				В	ПАКЕТНОМ	ЦИКЛЕ	ОБМЕНА		С	ПАМЯТЬЮ
 *				================================================
 *
 * Build 0x001 25.07.2002
 ---------------------------------------------------------------------------*/

// NOTE №1	Неблагоприятный порядок запроса ячеек возможен только при чтении
//========	завистых данных.

// NOTE №2	Это распростаняется и на основную память и на L2 кэш
// ========

// КОНФИГУРАЦИЯ
#define BLOCK_SIZE	(4*M)					// размер обрабатываемого блока памяти
#define BRST_LEN	32						// кол-во байт в пакетном цикле обмена

#include <DoCPU.h>

main()
{
	int		a;
	int		*p;
	int		x =0, y = 0;

	// TITLE
	PRINT("=== демонстрация последовательности адресов в пакетном цикле обмена с памятью ===\n");
	PRINT_TITLE;

	// выделяем и иницилизируем память
	p = malloc(BLOCK_SIZE); memset(p, 0, BLOCK_SIZE);

	/*------------------------------------------------------------------------
	 *
	 *					НОРМАЛЬНЫЙ ПОРЯДОК ПЕРЕДАЧИ
	 *
	 -----------------------------------------------------------------------*/
	A_BEGIN(0)
		for (a = 0; a < (BLOCK_SIZE - BRST_LEN); a += BRST_LEN)
		{
			x += *(int *)((char *)p + a + 0x0 + x);
			x += *(int *)((char *)p + a + 0x8 + x);
		}
	A_END(0)


	/*------------------------------------------------------------------------
	 *
	 *						НАЧАЛЬНЫЙ И КОНЕЧНЫЙ АДРЕСА
	 *
	 -----------------------------------------------------------------------*/
	A_BEGIN(1)
		for (a = 0; a < (BLOCK_SIZE - BRST_LEN); a += BRST_LEN)
		{
			x += *(int *)((char *)p + a + 0x0  + x);
			x += *(int *)((char *)p + a + 0x18 + x);
		}
	A_END(1)


	/*------------------------------------------------------------------------
	 *
	 *	СОСЕДНИЕ АДРЕСА 0x8 & 0x10 НА ПЕРЕДАЮТСЯ В НАЧАЛЕ И КОНЦЕ ЦИКЛА
	 *
	 -----------------------------------------------------------------------*/
	A_BEGIN(2)
		for (a = 0; a < (BLOCK_SIZE - BRST_LEN); a += BRST_LEN)
		{
			// ======= ИСПРАВЛЕНИЕ ПОРЯДКА АДРЕСОВ НА БЛАГОПРИЯТНЫЙ =========
			// если мы начнем запрос ячеек с адреса 0x0, то ячейки 0x8 и 0x10
			// передадутся в смежных пакетов, а потому все будет путем!
			// *
			//y += *(int *)((int)p + a + 0x0 + 0x0 + 0); // 31 % vs 75
			y += *(int *)((int)p + a + 0x0 + 0x0 + y); // 88% vs 66%
			//x += *(int *)((char *)p + a + 0x0 + 0x0 + x); // 111% vs 133% <- ops!
			// 117% vs 133%
			// ===============================================================
			x += *(int *)((char *)p + a + 0x0 + 0x8 + x);
			x += *(int *)((char *)p + a + 0x8 + 0x10 + x);
		}
	A_END(2)

	// выврод результатов на консоль
	Ax_OUT("NORMAL vs FIRST-to-END", 0, 1);
	Ax_OUT("NORMAL vs OPTIMIZED   ", 0, 2);

	return x+y;
}
