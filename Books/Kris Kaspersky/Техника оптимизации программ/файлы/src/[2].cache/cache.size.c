/*----------------------------------------------------------------------------
 *						
 *						ПРИМЕР ДЕМОНСТРИРУЕТ ЗАВИСИМОСТЬ:
 *				ПРОИЗВОДИТЕЛЬНОСТЬ (РАЗМЕР ОБРАБАТЫВАЕМОГО БЛОКА ДАННЫХ)
 *				========================================================
 *
 * Build 0x02 29.08.02
 * Build 0x01 30.05.02
--------------------------------------------------------------------------- */

// КОНФИГУРАЦИЯ
#define	BLOCK_SIZE	(745*K)	// размер обрабатываемого блока памяти
#define STEP_FACTOR	(1*K)	// шаг приращения перебираемого размера
#define X			b		// :'b' - для вычитания линейной составляющей
							// :'1' - показывать график как есть

#include <DoCPU.h>

main()
{
	int *p;
	int b, c;
	int tmp = 0;

	#ifdef MOVE_STACK
		char o_b[20*K];
	#endif

	// выделяем память
	p = malloc(BLOCK_SIZE);

	// шапка для таблицы
	printf("---\t");
	for (b = 1*K; b < BLOCK_SIZE; b += STEP_FACTOR)
		printf("%d\t",b/K); printf("\n");
	

	/*------------------------------------------------------------------------
	 *
	 *							ПОСЛЕДОВАТЕЛЬНОЕ ЧТЕНИЕ
	 *
	 ---------------------------------------------------------------------- */
	printf("R\t");	for (b = 1*K; b < BLOCK_SIZE; b += STEP_FACTOR)
	{ //			^^^^^^^^^^^^ цикл перебора блоков разного размера
		// выводим прогресс
		PRINT_PROGRESS(25*b/BLOCK_SIZE); VVV;

		// НАЧАЛО ЗАМЕРА ВРЕМЕНИ ВЫПОЛНЕНИЯ ОБРАБОТКИ БЛОКА РАЗМЕРА b
		A_BEGIN(0)
			for (c = 0; c <= b; c += sizeof(int)*4)
			{ //								 ^- степень развертки цикла
				tmp += *(int*)((char *)p + c + 0);
				tmp += *(int*)((char *)p + c + 4);
				tmp += *(int*)((char *)p + c + 8);
				tmp += *(int*)((char *)p + c + 12);
			}
		A_END(0)		// конец замера

		// вывод резльтатов замера на консоль
		printf("%d\t", 100*Ax_GET(0)/X);
	}
	printf("\n");


	/*------------------------------------------------------------------------
	 *
	 *							ПОСЛЕДОВАТЕЛЬНАЯ ЗАПИСЬ
	 *
	 ---------------------------------------------------------------------- */
	printf("W\t"); for (b = 1*K; b < BLOCK_SIZE; b += STEP_FACTOR)
	{
		PRINT_PROGRESS(25+25*b/BLOCK_SIZE); VVV;

		A_BEGIN(1)
			for (c = 0; c <= b; c += sizeof(int)*4)
			{
				*(int*)((char *)p + c + 0) = tmp;
				*(int*)((char *)p + c + 4) = tmp;
				*(int*)((char *)p + c + 8) = tmp;
				*(int*)((char *)p + c + 12) = tmp;
			}
		A_END(1)

		printf("%d\t", 100*Ax_GET(1)/X);
	}
	printf("\n");


	/*------------------------------------------------------------------------
	 *
	 *					ПОСЛЕДОВАТЕЛЬНОЕ ЧТЕНИЕ потом ЗАПИСЬ
	 *
	 ---------------------------------------------------------------------- */
	printf("RW\t"); for (b = 1*K; b < BLOCK_SIZE; b += STEP_FACTOR)
	{
		PRINT_PROGRESS(50+25*b/BLOCK_SIZE); VVV;

		A_BEGIN(2)
			for (c = 0; c <= b; c += sizeof(int)*2)
			{
				tmp += *(int*)((char *)p + c + 0);
				tmp += *(int*)((char *)p + c + 4);
				*(int*)((char *)p + c + 0) = tmp;
				*(int*)((char *)p + c + 4) = tmp;

			}
		A_END(2)

		printf("%d\t", 100*Ax_GET(2)/X);
	}
	printf("\n");


	/*------------------------------------------------------------------------
	 *
	 *					ПОСЛЕДОВАТЕЛЬНОЕ ЧТЕНИЕ потом ЗАПИСЬ
	 *
	 ---------------------------------------------------------------------- */
	printf("WR\t"); for (b = 1*K; b < BLOCK_SIZE; b += STEP_FACTOR)
	{
		PRINT_PROGRESS(75+25*b/BLOCK_SIZE); VVV;

		A_BEGIN(3)
			for (c = 0; c <= b; c += sizeof(int)*2)
			{
				*(int*)((char *)p + c + 0) = tmp;
				*(int*)((char *)p + c + 4) = tmp;
				tmp += *(int*)((char *)p + c + 0);
				tmp += *(int*)((char *)p + c + 4);
			}
		A_END(3)

		printf("%d\t", 100*Ax_GET(3)/X);
	}
	printf("\n");

	return tmp;
}
