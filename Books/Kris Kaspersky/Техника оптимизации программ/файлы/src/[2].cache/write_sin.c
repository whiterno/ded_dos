/*----------------------------------------------------------------------------
 *
 *					ПРИМЕР, ДЕМОНСТРИРУЮЩИЙ ЭФФЕКТИВНОЕ
 *				ИСПОЛЬЗОВАНИЕ БУФЕРОВ ЗАПИСИ (STORE BUFFERS)
 *
 * Build 0x001 08.08.2002
----------------------------------------------------------------------------*/

// КОНФИГУРАЦИЯ
//#define __WRITE_MISS__
// расскомментируйте это для тестирования промахов записи
// в проивном случае запись  будет  происходить в память,
// уже находящуюся в L1-кэше

#include <DoCPU.h>

main()
{
	int		*p;
	int		a, b, d;
	float	x = 0.666;

	// TITLE
	PRINT("= = = использование буферов записи = = =\n");
	PRINT_TITLE;

	// выделение памяти
	p = malloc(1*M);

	/*------------------------------------------------------------------------
	 *
	 *						НЕОПТИМИЗИРОВАННЫЙ ВАРИАНТ
	 *
	------------------------------------------------------------------------*/
	A_BEGIN(0)
		// 192 ячейки типа DWORD дают в сумме 776 байт памяти,
		// что  вдвое  превышает  емкость  буферов  записи  на
		// процессорах P-II/P-III.Где-то наполовине исполнения
		// возникнет затор и дальнейшие операции записи  будут
		// исполняться   гораздо  медленее, т.е.  им  придется
		// всякий раз дожидаться выгрузки буферов
		for(a = 0; a < 192; a += 8)
		{
			// для устанения накладных расходов цикл
			// должен   быть  развернут,  иначе  его
			// расщепление снизит производительность
			p[a + 0] = (a + 0);
			p[a + 1] = (a + 1);
			p[a + 2] = (a + 2);
			p[a + 3] = (a + 3);
			p[a + 4] = (a + 4);
			p[a + 5] = (a + 5);
			p[a + 6] = (a + 6);
			p[a + 7] = (a + 7);
		}
		
		// делаем некоторые вычисления
		for(b = 0; b < 66; b++)
			x += x/cos(x);
		
		#ifdef __WRITE_MISS__
			// тестируем запись в память,
			// отсутствующую в L1-кэше
			p += 196;
		#else
			// тестируем запись в память,
			// присутствующую к L1-кэше
		#endif

	A_END(0)

	/*------------------------------------------------------------------------
	 *
	 *						ОПТИМИЗИРОВАННЫЙ ВАРИАНТ
	 *
	------------------------------------------------------------------------*/
	A_BEGIN(1)

		// выполняем  часть   запланированных   вычислений,
		// с таким расчетом, что бы буферам хватило времени
		// на сброс их  текущего  содержимого, ведь  отнюдь
		// не факт,  что на момент начала выполнения  цикла
		// буфера пусты
		for(b = 0; b < 33; b++)
			x += x/cos(x);

		// выполняем  96  записей  ячеек  типа  DWORD,  что
		// соответвует емкости  буферов  записи; к  моменту
		// заверщения цикла практически  все  буфера  будут
		// забиты."Практически" - потому что какая-то часть
		// из них уже успеет выгрузится
		for(a = 0; a < 96; a += 8)
		{
			p[a + 0] = (a + 0);
			p[a + 1] = (a + 1);
			p[a + 2] = (a + 2);
			p[a + 3] = (a + 3);
			p[a + 4] = (a + 4);
			p[a + 5] = (a + 5);
			p[a + 6] = (a + 6);
			p[a + 7] = (a + 7);
		}

		// выполняем  оставшуюся   часть  вычислений. Будет
		// просто замечательно,если за это время все буфера
		// успеют аккурат выгрузится, - тогда мы  достигнет
		// полного параллелизма!
		for(b = 0; b < 33; b++)
			x += x/cos(x);

		// выполняем  оставшиеся 96 записий. Поскольку  они
		// к   этому   моменту  уже  освободились,   запись
		// протекает так быстро, как это только возможно
		for(a = 96; a < 192; a += 8)
		{
			p[a + 0] = (a+0);
			p[a + 1] = (a+1);
			p[a + 2] = (a+2);
			p[a + 3] = (a+3);
			p[a + 4] = (a+4);
			p[a + 5] = (a+5);
			p[a + 6] = (a+6);
			p[a + 7] = (a+7);
		}
		#ifdef __WRITE_MISS__
			// тестируем запись в память,
			// отсутствующую в L1-кэше
			p+=196;
		#else
			// тестируем запись в память,
			// присутствующую к L1-кэше
		#endif	
	A_END(1)

	/*------------------------------------------------------------------------
	 *
	 *				ОПТИМИЗИРОВАННЫЙ СВЕРНУТЫЙ ВАРИАНТ
	 *
	------------------------------------------------------------------------*/
	A_BEGIN(2)

		// введение нового цикла позволяет исключить повторяющийся код,
		// повышая тем самым компактность программы.
		for(d = 0;d<192;d += 96)
		{
			for(b = 0; b < 33; b++)
				x += x/cos(x);

			for(a = d; a < d+96; a += 8)
			{
				p[a + 0] = (a + 0);
				p[a + 1] = (a + 1);
				p[a + 2] = (a + 2);
				p[a + 3] = (a + 3);
				p[a + 4] = (a + 4);
				p[a + 5] = (a + 5);
				p[a + 6] = (a + 6);
				p[a + 7] = (a + 7);
			}
		}

		#ifdef __WRITE_MISS__
			// тестируем запись в память,
			// отсутствующую в L1-кэше
			p+=196;
		#else
			// тестируем запись в память,
			// присутствующую к L1-кэше
		#endif
	A_END(2)

	// вывод результатов на консоль
	Lx_OUT("OPTIMIZE FOR SPEED        ",Ax_GET(0),Ax_GET(1));
	Lx_OUT("OPTIMIZE FOR SPEED & SPACE",Ax_GET(0),Ax_GET(2));
}


