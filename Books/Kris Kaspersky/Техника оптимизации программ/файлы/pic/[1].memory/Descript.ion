1.00.logo4.gif Память... Миллиарды битовых ячеек, упакованных в крошечную керамическую пластинку, свободно умещающуюся на ладони: вот как выглядит современная оперативная память!
Descript.ion /cat/root
1.01.doc Иерархия памяти в операционных системах Windows 9x/NT/2000 и UNIX (грубо)
1.02.tif 1024-битное ядро памяти компьютера UNIVAC-11015. Действительный размер этого ядра составляет 5.5 см. Похожее на грубо обработанную мешковину, оно, в действительности, состоит из многочисленных ферритовых "пончиков", каждый из которых может хранить всего лишь один бит информации. По легенде, намотку ферритовых колец осуществляли: девушки, вооруженные стереоскопическим микроскопом. Мужчины, по всей видимости оказывались слишком неуклюжими и недостаточно усидчивыми для этой тонкой и чрезвычайно кропотливой работы. (Попробовал бы сегодня кто-нибудь намотать 1 гигобит ячеек памяти вручную!). Восемь таких ядер объединялись в стопку, реализуя на пересечении столбцов и колонок целый байт информации (термин "машинное слово" в те годы еще не был изобретен!).
1.03.tif Схематическое изображение модуля оперативной памяти (1); микросхемы памяти (2); матрицы (3) и отдельной ячейки памяти (4)
1.04.tif Устройство ячейки современной микросхемы динамической памяти
1.05.tif Временная диаграмма, иллюстрирующая работу некоторых типов памяти
1.06.tif Временная диаграмма, иллюстрирующая работу некоторых типов памяти (окончание)
1.07.doc Максимально достижимая пропускная способность основных типов памяти
1.08.tif Устройство серверного моста чипсета Intel 815EP, содержащего (среди всего прочего) контроллер памяти
1.09.tif Внешний вид чипсета Intel 815EP
1.10.tif Устройство механизма взаимодействия с памятью в чипсете AMD 750
1.11.tif Типовая схема трансляция процессорных адресов в физические адреса DRAM-памяти
1.11.doc Эффективность разворачивания циклов, читающих память. Видно, что время выполнения цикла резко уменьшается с его глубиной
1.12.doc Эффективность разворачивания циклов, записывающих память. Время выполнения цикла практически не зависит от глубины развертки и лишь на AMD Athlon шестнадцати кратная развертка несколько увеличивает его производительность
1.13.doc Тест пропускной способности оперативной памяти при линейном чтении зависимых и независимых данных. На "правильном" чипсете Intel 815EP независимые данные обрабатываются в два с половиной раза быстрее. На чипсете VIA KT133 (за счет его высокой латентности) различие в производительности намного меньше и составляет всего 1,7 крат. Но, как бы так ни было, на любой системе обрабатывать зависимые данные крайне невыгодно. Обратите также внимание, что при линейном чтении данных заявленная пропускная способность (800 Мб/сек. для данного типа памяти) не достигается
1.14.tif По возможности избегайте линейного чтения ячеек памяти. Лучше в первом проходе цикла читать ячейки с шагом, кратным размеру пакетного цикла обмена, а оставшиеся ячейки обрабатывать как обычно
1.15.doc Демонстрация эффективности параллельного чтения. На AMD Athlon 1050/100/100/VIA KT133 этот простой и элегантный трюк обеспечивает более чем двукратный прирост производительности. На P-III 733/133/100/I815EP выигрыш, правда, гораздо меньше - 20% - но все равно более чем ощутим
1.16.doc Зависимость времени обработки данных от степени расщепления списков. Как видно, наилучшая стратегия заключается в шестикратном расщеплении списков. Это обеспечивает наилучший компромисс для обоих процессоров
1.17.tif Устройство "классического" списка. При трассировке процессор вынужден загружать и ссылки, и значения, несмотря на то, что нас интересуют одни лишь ссылки
1.18.tif Устройство оптимизированного списка. Теперь при трассировке процессор загружает лишь те ячейки, к которым происходит реальное обращение, что значительно увеличивает производительность системы
1.19.tif Отводите указателям минимально возможное количество бит, - это здорово сократит объем занимаемой памяти
1.20.doc Демонстрация эффективности обработки раздельных списков с указателями усеченной разрядности. Как видно, это значительно сокращает время трассировки списков, причем трехкратный выигрыш производительности (достигнутый в данном случае) - далеко не предел!
1.21.doc Демонстрация эффективности различных подходов к оптимизации структуры (14) Учет особенностей станичной организации памяти (см. ниже) позволяет более чем в два раза сократить время обработки списка
1.22.doc График, иллюстрирующий время обработки блока данных в зависимости от шага чтения. На P-III насыщение наступает на 32 Кб шаге чтение данных, а на AMD Athlon - на 64 Кб. Причем, на участке (0; 4Кб] происходит резкий "влет" кривой, особенно хорошо заметный на AMD Athlon
1.23.doc График, иллюстрирующий зависимость времени доступа к ячейке от адреса этой ячейки при последовательном обращении к данным. Смотрите, - при первом обращении к странице возникает пауза в десятки тысяч тактов!
1.24.doc График, иллюстрирующий время обработки блока данных в зависимости от шага чтения при отсутствии и присутствии страниц в TLB. Обратите внимание на "волнистость" нижней кривой. Это - прямое следствие регенерации DRAM банков оперативной памяти
1.25.tif "Волны" памяти несут чрезвычайно богатую информацию о конструктивных особенностях используемых микросхем памяти. Вот только основные характеристики: а. - расстояние между концом одной и началом следующей DRAM-страницы того же самого DRAM-банка; b. - расстояние между началом одной и началом другой DRAM-страницы того же самого DRAM-банка (т.е. размер всех DRAM-банков); c. и d. - размер одной DRAM-страницы. Кол-во DRAM банков равно b/d
1.26.tif Виртуализация потоков данных. Несколько исходных потоков (слева) сливаются в один физический поток, сконструированный по принципу чередования адресов, что фактически равносильно его расщеплению на два логических потока
1.27.doc Демонстрация эффективности виртуализации потоков данных на системе P-III 733/133/100/I815EP/2x4. Уже на 16 потоках оптимизация дает более чем трехкратный выигрыш
1.28.doc Демонстрация эффективности виртуализации потоков данных на системе P-III/I815EP/2x4 AMD Athlon/VIA KT133/4x4
1.29.doc Демонстрация особенностей механизма буферизации на чипсете VIA KT133. Смотрите, при узком "зазоре" между виртуальными потоками время их обработке чудовищно возрастает
1.30.doc Сравнительная эффективность чтения/записи больших блоков памяти байтами, двойными и четверными словами. Как видно: чтение памяти лучше всего осуществлять двойными словами, а запись - либо байтами, либо двойными словами. Обработка памяти четвертными словами всегда осуществляется наименее эффективно
1.31.doc Эффективность выравнивания начального адреса при обработке больших массивов данных. Не выровненный начальный адрес читаемого потока памяти несет ~15% издержки производительности. Записывание данных, напротив, не требует выравнивания, а на AMD Athlon не выровненные данные обрабатываются даже быстрее
1.32.doc Влияние на производительность выравнивания адресов источника и приемника при копировании памяти. Главное - выровнять источник. Выравниванием же начального адреса приемника можно пренебречь
1.33.tif Техника эффективной обработки не выровненного двухсловного потока данных
1.34.doc Описанная методика "эффективной" обработки не выровненного двухсловного потока данных, на самом деле снижает производительность. Самое интересное, что не выровненный поток на AMD Athlon обрабатывается даже быстрее, чем выровненный!
1.35.tif Техника выравнивания байтовых потоков данных. В отличии от выравнивая двухсловных потоков, она действительно эффективна
1.36.doc Демонстрация эффективности выравнивания байтовых потоков данных. Легко видеть, что предложенная техника выравнивания на 100% эффективна
1.37.doc Демонстрация эффективности комбинирования вычислительных операций с командами, обращающихся к памяти
1.38.doc Демонстрация влияния перекрытия транзакций чтения/записи на время обработки больших блоков данных с учета разворота цикла и без. Если на P-III перекрытие транзакций практически не влияет на производительность, то на AMD Athlon проигрыш уже становится ощутим, хотя и не так велик, что бы перечеркивать все выше написанное
1.39.doc  Демонстрация эффективности параллельного копирования памяти. Выигрыш особенно ощутим на процессорах Athlon - целых ~30% производительности
1.40.tif Копирование перекрывающихся блоков памяти. Если источник расположен правее приемника (верхний рисунок), то перенос ячеек памяти происходит без каких-либо проблем. Напротив, если источник расположен левее приемника (нижний рисунок), то перенос ячеек "вперед" приведет к затиранию источника
1.41.doc Демонстрация эффективности различных алгоритмов переноса памяти
1.43.doc Демонстрация эффективности различных алгоритмов переноса памяти (увеличено)
1.42.tif "Четырехтактный" алгоритм прямого переноса памяти с использованием двух промежуточных буферов
1.44.doc Сравнение функций memmove и MyMemMove на системе AMD Athlon 1050/100/100/VIA KT133
1.45.doc Демонстрация эффективности различных алгоритмов сравнения блоков памяти
1.46.doc Сравнительная характеристика шатанных функций компилятора Microsoft Visual C++ и эквивалентных им функций операционной системы. Кстати, все они в той или иной степени не оптимальны
1.47.tif Устройство Си, Pascal, Delphi и MFC-строк. Си-строки могут иметь неограниченную длину, но не могут содержать в себе символа нуля, т.к. он трактуется как завершитель строки. Pascal-строки хранят длину строки в специальном однобайтовом поле, что значительно увеличивает эффективность строковых функций, позволяет хранить в строках любые символы, но ограничивает их размер 256 байтами. Delphi-строки представляют собой разновидность Pascal-строк и отличаются от них лишь увеличенной разрядностью поля длины, теперь строки могут достигать 64Кб длины. MFC-строки - это гибрид Си и Pascal строк с 32-битным полем длины, благодаря чему макс. длина строки теперь равна 4Гб.
1.48.doc Сравнение эффективности MFC и Си функций, работающий со строками. Как видно, MFC строки более производительны
1.49.tif Устранение зависимости по данным путем упреждающей загрузки следующего обрабатываемого блока
1.50.doc Время сортировки различного количества чисел алгоритмами quick sort и linear sort
1.51.tif Сортировка методом отображения
1.52.doc Превосходство линейной сортировки над qsort. Смотрите, линейная сортировка двух миллионов чисел (вполне реальное количество, правда) выполняется в двести пятьдесят раз быстрее!
